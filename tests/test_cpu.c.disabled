/*
 * test_cpu.c - CPU emulation tests
 * 
 * Tests for the 65c816 CPU basic functionality
 */

#include "test_framework.h"
#include "../include/cpu.h"
#include "../include/memory.h"
#include <string.h>

/* Test CPU initialization */
void test_cpu_initialization(void) {
    TEST("CPU initialization");
    
    CPU cpu;
    cpu_init(&cpu);
    
    /* Verify initial state */
    ASSERT(cpu.e == 1);  /* Should start in emulation mode */
    ASSERT(cpu.p & FLAG_I);  /* IRQ disabled at start */
    ASSERT(cpu.cycles == 0);
    ASSERT(cpu.stopped == false);
    ASSERT(cpu.breakpoint_count == 0);
    
    TEST_PASS();
}

/* Test CPU reset */
void test_cpu_reset(void) {
    TEST("CPU reset operation");
    
    CPU cpu;
    cpu_init(&cpu);
    
    /* Modify state */
    cpu.cycles = 1000;
    cpu.a = 0x1234;
    cpu.x = 0x5678;
    
    /* Reset should restore initial state */
    cpu_reset(&cpu);
    
    ASSERT(cpu.e == 1);
    ASSERT(cpu.p & FLAG_I);
    /* cycles may not reset to maintain timing */
    
    TEST_PASS();
}

/* Test CPU flag manipulation */
void test_cpu_flags(void) {
    TEST("CPU flag operations");
    
    CPU cpu;
    cpu_init(&cpu);
    
    /* Test setting flags */
    cpu_set_flag(&cpu, FLAG_C, true);
    ASSERT(cpu_get_flag(&cpu, FLAG_C) == 1);
    
    cpu_set_flag(&cpu, FLAG_Z, true);
    ASSERT(cpu_get_flag(&cpu, FLAG_Z) == 1);
    
    cpu_set_flag(&cpu, FLAG_N, true);
    ASSERT(cpu_get_flag(&cpu, FLAG_N) == 1);
    
    /* Test clearing flags */
    cpu_set_flag(&cpu, FLAG_C, false);
    ASSERT(cpu_get_flag(&cpu, FLAG_C) == 0);
    
    TEST_PASS();
}

/* Test breakpoint management */
void test_cpu_breakpoints(void) {
    TEST("CPU breakpoint management");
    
    CPU cpu;
    cpu_init(&cpu);
    
    /* Add breakpoints */
    bool added = cpu_add_breakpoint(&cpu, 0x008000);
    ASSERT(added == true);
    ASSERT(cpu.breakpoint_count == 1);
    
    added = cpu_add_breakpoint(&cpu, 0x00C000);
    ASSERT(added == true);
    ASSERT(cpu.breakpoint_count == 2);
    
    /* Remove breakpoint */
    bool removed = cpu_remove_breakpoint(&cpu, 0x008000);
    ASSERT(removed == true);
    ASSERT(cpu.breakpoint_count == 1);
    
    /* Clear all */
    cpu_clear_breakpoints(&cpu);
    ASSERT(cpu.breakpoint_count == 0);
    
    TEST_PASS();
}

/* Test breakpoint limits */
void test_cpu_breakpoint_limits(void) {
    TEST("CPU breakpoint limits");
    
    CPU cpu;
    cpu_init(&cpu);
    
    /* Fill up all breakpoint slots */
    for (int i = 0; i < 8; i++) {
        bool added = cpu_add_breakpoint(&cpu, 0x8000 + (i * 0x1000));
        ASSERT(added == true);
    }
    
    ASSERT(cpu.breakpoint_count == 8);
    
    /* Try to add one more - should fail */
    bool added = cpu_add_breakpoint(&cpu, 0xFFFF);
    ASSERT(added == false);
    ASSERT(cpu.breakpoint_count == 8);
    
    TEST_PASS();
}

/* Test CPU state preservation */
void test_cpu_state_preservation(void) {
    TEST("CPU state preservation");
    
    CPU cpu;
    cpu_init(&cpu);
    
    /* Set specific state */
    cpu.a = 0x1234;
    cpu.x = 0x5678;
    cpu.y = 0x9ABC;
    cpu.sp = 0x01FF;
    cpu.pc = 0x8000;
    cpu.dbr = 0x80;
    cpu.pbr = 0x00;
    cpu.d = 0x2000;
    
    /* Verify state is retained */
    ASSERT_EQ(cpu.a, 0x1234);
    ASSERT_EQ(cpu.x, 0x5678);
    ASSERT_EQ(cpu.y, 0x9ABC);
    ASSERT_EQ(cpu.sp, 0x01FF);
    ASSERT_EQ(cpu.pc, 0x8000);
    ASSERT_EQ(cpu.dbr, 0x80);
    ASSERT_EQ(cpu.pbr, 0x00);
    ASSERT_EQ(cpu.d, 0x2000);
    
    TEST_PASS();
}

/* Test emulation mode flag */
void test_cpu_emulation_mode(void) {
    TEST("CPU emulation mode");
    
    CPU cpu;
    cpu_init(&cpu);
    
    /* Should start in emulation mode */
    ASSERT(cpu.e == 1);
    
    /* In emulation mode, certain flags should be set */
    ASSERT(cpu.p & FLAG_M);  /* 8-bit accumulator */
    ASSERT(cpu.p & FLAG_X);  /* 8-bit index registers */
    
    TEST_PASS();
}

/* Test interrupt flags */
void test_cpu_interrupt_flags(void) {
    TEST("CPU interrupt flags");
    
    CPU cpu;
    cpu_init(&cpu);
    
    /* Initially no interrupts pending */
    ASSERT(cpu.nmi_pending == false);
    ASSERT(cpu.irq_pending == false);
    
    /* Trigger NMI */
    cpu_nmi(&cpu);
    ASSERT(cpu.nmi_pending == true);
    
    /* Trigger IRQ */
    cpu_irq(&cpu);
    ASSERT(cpu.irq_pending == true);
    
    TEST_PASS();
}

/* Test cycle counting */
void test_cpu_cycle_counting(void) {
    TEST("CPU cycle counting");
    
    CPU cpu;
    cpu_init(&cpu);
    
    u64 initial_cycles = cpu.cycles;
    
    /* Cycles should be tracked */
    ASSERT(initial_cycles == 0);
    
    /* After operations, cycles should increase */
    /* (This would require actual instruction execution) */
    
    TEST_PASS();
}

/* Test suite runner */
void test_cpu_suite(void) {
    TEST_SUITE("CPU Module");
    
    test_cpu_initialization();
    test_cpu_reset();
    test_cpu_flags();
    test_cpu_breakpoints();
    test_cpu_breakpoint_limits();
    test_cpu_state_preservation();
    test_cpu_emulation_mode();
    test_cpu_interrupt_flags();
    test_cpu_cycle_counting();
}
